interface AiThoughtsState {
  isAiThinking: boolean;
  aiThoughts: string;
}

// Update thoughts during analysis
function updateAiThoughts(stage: string, details: string) {
  const timestamp = new Date().toLocaleTimeString();
  const thoughts = `[${timestamp}] ${stage}\n${details}`;
  
  useTradingStore.getState().setAiThoughts(thoughts);
}

// Example usage
updateAiThoughts('üîç Market Data', `
  Fetched prices for 3 coins:
  ‚Ä¢ BTCUSD: $45,000
  ‚Ä¢ ETHUSD: $2,500
  ‚Ä¢ SOLUSD: $100
`);

async function executeAIRecommendation(
  analysis: AIAnalysisResponse,
  currentPosition: Position | null
): Promise<void> {
  
  // STEP 1: Validate recommendation against allowed coins
  if (!settings.allowedCoins.includes(analysis.recommendedSymbol)) {
    toast.warning(`AI recommended ${analysis.recommendedSymbol} but it's not in allowed coins`);
    await logTradeSkipped(analysis);
    return;
  }
  
  // STEP 2: Handle close action
  if (analysis.action === 'close' && currentPosition) {
    await closePosition(currentPosition);
    return;
  }
  
  // STEP 3: Handle hold action
  if (analysis.action === 'hold') {
    toast.info(`AI recommends: HOLD (Confidence: ${analysis.confidence}%)`);
    return;
  }
  
  // STEP 4: Validate trade parameters
  if (!analysis.entryPrice || !analysis.stopLoss || !analysis.takeProfit) {
    throw new Error('Missing trade parameters');
  }
  
  // STEP 5: Risk management checks
  const riskCheck = await performRiskChecks({
    symbol: analysis.recommendedSymbol,
    side: analysis.action === 'open_long' ? 'long' : 'short',
    size: analysis.positionSize,
    entryPrice: analysis.entryPrice,
    leverage: settings.leverage,
  });
  
  if (!riskCheck.passed) {
    toast.error(`Trade rejected: ${riskCheck.reason}`);
    await logTradeRejected(analysis, riskCheck.reason);
    return;
  }
  
  // STEP 6: Execute trade
  const side = analysis.action === 'open_long' ? 'long' : 'short';
  
  await executeTrade(
    analysis.recommendedSymbol,
    analysis.action,
    side,
    analysis.entryPrice,
    analysis.positionSize,
    analysis.stopLoss,
    analysis.takeProfit,
    analysis.reasoning,
    true // skipConfirmation for auto-trading
  );
  
  // STEP 7: Log successful execution
  toast.success(`‚úÖ ${side.toUpperCase()} ${analysis.recommendedSymbol} opened`);
}

enum AIAnalysisError {
  API_KEY_INVALID = 'Invalid or missing API key',
  NO_MARKET_DATA = 'Failed to fetch market data',
  AI_TIMEOUT = 'AI analysis timed out',
  PARSE_ERROR = 'Failed to parse AI response',
  VALIDATION_ERROR = 'AI response validation failed',
  RATE_LIMIT = 'Rate limit exceeded',
}

async function handleAnalysisError(
  error: Error,
  retryCount: number
): Promise<void> {
  
  // Log error
  await pythonApi.createTradingLog({
    action: 'ai_error',
    symbol: 'SYSTEM',
    reason: `AI Analysis Error: ${error.message}`,
    details: `Retry count: ${retryCount}`,
  });
  
  // Determine recovery strategy
  if (error.message.includes('API key')) {
    // Stop auto-trading, require user intervention
    setAutoTrading(false);
    toast.error('Auto-trading paused: Invalid API key');
    
  } else if (error.message.includes('Rate limit')) {
    // Wait and retry
    const waitTime = 60000; // 1 minute
    toast.warning(`Rate limit hit. Waiting ${waitTime / 1000}s...`);
    await new Promise(resolve => setTimeout(resolve, waitTime));
    
  } else if (retryCount < 3) {
    // Retry with exponential backoff
    const backoff = Math.pow(2, retryCount) * 1000;
    await new Promise(resolve => setTimeout(resolve, backoff));
    
  } else {
    // Max retries exceeded, pause auto-trading
    setAutoTrading(false);
    toast.error('Auto-trading paused: Repeated AI failures');
  }
}

// Trigger manual analysis from UI
async function handleManualAnalysis() {
  try {
    setIsAnalyzing(true);
    
    const charts = await fetchMarketDataForAllowedCoins();
    const analysis = await runMultiChartAIAnalysis(charts);
    
    if (analysis) {
      // Show confirmation modal
      setTradeConfirmation({
        show: true,
        analysis,
      });
    }
    
  } catch (error) {
    toast.error(`Analysis failed: ${error.message}`);
  } finally {
    setIsAnalyzing(false);
  }
}

useEffect(() => {
  if (!isAutoTrading) return;
  
  let isActive = true;
  let timeoutId: NodeJS.Timeout | null = null;
  
  const runAutoTradingCycle = async () => {
    if (!isActive) return;
    
    try {
      // Fetch market data
      const charts = await fetchMarketDataForAllowedCoins();
      
      // Run AI analysis
      const analysis = await runMultiChartAIAnalysis(charts);
      
      // Execute recommendation
      if (analysis) {
        await executeAIRecommendation(analysis, position);
      }
      
    } catch (error) {
      await handleAnalysisError(error, 0);
    }
  };
  
  // Run immediately
  runAutoTradingCycle();
  
  // Schedule next cycle (60 seconds)
  const scheduleNext = () => {
    if (isActive) {
      timeoutId = setTimeout(() => {
        runAutoTradingCycle().then(scheduleNext);
      }, 60000);
    }
  };
  scheduleNext();
  
  return () => {
    isActive = false;
    if (timeoutId) clearTimeout(timeoutId);
  };
}, [isAutoTrading, settings.allowedCoins]);

// Optimal settings for different scenarios

// Conservative (Demo/Learning)
const conservativeSettings = {
  allowedCoins: ['BTCUSD'], // Single coin
  leverage: 2,
  takeProfitPercent: 1.5,
  stopLossPercent: 0.75,
  aiModel: 'deepseek/deepseek-chat-v3-0324:free',
};

// Balanced (Paper Trading)
const balancedSettings = {
  allowedCoins: ['BTCUSD', 'ETHUSD'],
  leverage: 5,
  takeProfitPercent: 2,
  stopLossPercent: 1,
  aiModel: 'deepseek/deepseek-chat-v3-0324:free',
};

// Aggressive (Live Trading)
const aggressiveSettings = {
  allowedCoins: ['BTCUSD', 'ETHUSD', 'SOLUSD'],
  leverage: 10,
  takeProfitPercent: 3,
  stopLossPercent: 1.5,
  aiModel: 'qwen/qwen3-max', // Paid model for better accuracy
};